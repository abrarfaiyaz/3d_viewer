<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Graph with Selectable Nodes and Improved Touch + OrbitControls</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        .label {
            position: absolute;
            background-color: white;
            padding: 2px 5px;
            border-radius: 3px;
            border: 1px solid #000;
            font-size: 12px;
            pointer-events: none;  /* Makes the label unclickable */
        }
        .mode-button {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px 15px;
            font-size: 16px;
            background-color: #333;
            color: white;
            cursor: pointer;
            border: none;
            border-radius: 5px;
        }
    </style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

<script>
// Initialize the scene
let scene = new THREE.Scene();

// Set up the camera
let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 20);  // Move the camera back to see the graph

// Set up the renderer
let renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Add lighting
let ambientLight = new THREE.AmbientLight(0x404040, 2);  // Soft ambient light
scene.add(ambientLight);

let directionalLight = new THREE.DirectionalLight(0xffffff, 1);
directionalLight.position.set(10, 10, 10);
scene.add(directionalLight);

// OrbitControls for interaction
let controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;

// Raycaster and mouse position for detecting clicks/touches
let raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2();

// Array to store all node meshes for raycasting
let nodeMeshes = [];
// Array to store labels
let labels = {};

// Mode variable to distinguish between transformation and selection/labeling
let mode = 'transform';  // Possible values: 'transform', 'select'

// Create a button to switch modes
let modeButton = document.createElement('button');
modeButton.className = 'mode-button';
modeButton.innerHTML = 'Switch to Selection Mode';
document.body.appendChild(modeButton);

// Function to switch modes
modeButton.addEventListener('click', () => {
    if (mode === 'transform') {
        mode = 'select';
        controls.enabled = false;  // Disable OrbitControls in select mode
        modeButton.innerHTML = 'Switch to Transform Mode';
        document.addEventListener('mouseup', onTouchEnd, false);  // Add node selection listener
    } else {
        mode = 'transform';
        controls.enabled = true;  // Enable OrbitControls in transform mode
        modeButton.innerHTML = 'Switch to Selection Mode';
        document.removeEventListener('mouseup', onTouchEnd, false);  // Remove node selection listener
    }
});

// Function to create a label for a node
function createLabel(text) {
    let label = document.createElement('div');
    label.className = 'label';
    label.innerHTML = text;
    document.body.appendChild(label);
    return label;
}

// Update label position based on node's position in the screen
function updateLabelPosition(label, node) {
    let vector = node.position.clone();
    vector.project(camera);
    
    let x = (vector.x * 0.5 + 0.5) * window.innerWidth;
    let y = (-vector.y * 0.5 + 0.5) * window.innerHeight;

    label.style.left = `${x}px`;
    label.style.top = `${y}px`;
}

// Function to load graph data from JSON file
function loadGraphData() {
    fetch('graph_data.json')  // Load external JSON file
        .then(response => response.json())
        .then(data => {
            // Create nodes
            let nodes = data.nodes.map(node => {
                let position = new THREE.Vector3(node.x, node.y, node.z);
                let geometry = new THREE.SphereGeometry(0.5, 32, 32);
                let material = new THREE.MeshPhongMaterial({ color: 0xff0000, shininess: 100, specular: 0x888888 });
                let sphere = new THREE.Mesh(geometry, material);
                sphere.position.copy(position);
                scene.add(sphere);
                nodeMeshes.push(sphere);  // Store the node mesh for raycasting
                return sphere;
            });

            // Create edges
            data.edges.forEach(edge => {
                let fromNode = nodeMeshes[edge.from].position;
                let toNode = nodeMeshes[edge.to].position;
                let edgeGeometry = new THREE.BufferGeometry().setFromPoints([fromNode, toNode]);
                let edgeMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff });
                let line = new THREE.Line(edgeGeometry, edgeMaterial);
                scene.add(line);
            });
        })
        .catch(error => console.error('Error loading graph data:', error));
}

// Call the function to load the graph
loadGraphData();

// Handle node selection on tap (after touch ends)
function onTouchEnd(event) {
    if (mode !== 'select') {
        return;  // Do nothing if we're not in selection mode
    }

    if (event.touches && event.touches.length > 1) {
        // If multi-touch, ignore as it's likely a gesture
        return;
    }

    event.preventDefault();

    let clientX, clientY;

    // Distinguish between touch and mouse events
    if (event.changedTouches) {
        clientX = event.changedTouches[0].clientX;
        clientY = event.changedTouches[0].clientY;
    } else {
        clientX = event.clientX;
        clientY = event.clientY;
    }

    // Convert screen coordinates to normalized device coordinates
    mouse.x = (clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(clientY / window.innerHeight) * 2 + 1;

    // Update the raycaster with the camera and pointer position
    raycaster.setFromCamera(mouse, camera);

    // Find intersections (clicked/touched nodes)
    let intersects = raycaster.intersectObjects(nodeMeshes);
    
    if (intersects.length > 0) {
        let clickedNode = intersects[0].object;

        // Prompt user for label
        let labelText = prompt("Enter label for this node:");

        if (labelText) {
            // Create or update the label
            if (labels[clickedNode.id]) {
                labels[clickedNode.id].innerHTML = labelText;
            } else {
                let label = createLabel(labelText);
                labels[clickedNode.id] = label;
            }

            // Update label position immediately
            updateLabelPosition(labels[clickedNode.id], clickedNode);
        }
    }
}

// Render function
function render() {
    controls.update();  // Update controls for interaction

    // Update label positions for all labeled nodes
    for (let nodeId in labels) {
        updateLabelPosition(labels[nodeId], nodeMeshes[nodeId]);
    }

    renderer.render(scene, camera);
}

// Animation loop
function animate() {
    requestAnimationFrame(animate);
    render();
}

// Handle window resizing
window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
});

// Start the animation loop
animate();
</script>
</body>
</html>
